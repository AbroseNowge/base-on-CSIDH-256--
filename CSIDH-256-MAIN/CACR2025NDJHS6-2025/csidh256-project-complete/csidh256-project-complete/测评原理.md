# CSIDH-256 性能测评原理文档

## 概述

本文档详细说明 CSIDH-256 项目中性能测评对比的实现原理和方法。性能测试通过多次迭代执行算法操作，测量总时间并计算平均值，以获得稳定可靠的性能数据。

## 一、迭代次数设置

项目中不同测试文件使用的迭代次数有所不同：

### 1.1 标准测试（10万次迭代）
- **文件**: `performance_test.c`, `performance_comparison_test.c`
- **迭代次数**: **100,000 次**
- **用途**: 常规性能对比测试

### 1.2 详细测试（100万次迭代）
- **文件**: `test/test_performance.c`, `detailed_performance_analysis.c`
- **迭代次数**: **1,000,000 次**
- **用途**: 高精度性能分析和详细报告

### 1.3 稳定性测试
- **文件**: `performance_stability_test.c`
- **迭代次数**: 50,000 次（每次测试）
- **测试次数**: 多次运行，统计平均值、最小值、最大值
- **用途**: 评估性能稳定性和一致性

## 二、测试流程

性能测试采用标准的基准测试流程，包含以下三个阶段：

### 2.1 预热阶段（Warm-up）

```c
// 预热：执行1000次迭代，消除冷启动影响
for (int i = 0; i < 1000; i++) {
    func(&result, &TEST_A, &TEST_B);
}
```

**目的**：
- 消除冷启动影响（CPU频率提升、缓存预热）
- 让JIT编译器完成优化（如果适用）
- 确保测试环境稳定

### 2.2 正式测试阶段

```c
// 记录开始时间
double start_time = get_time_ms();

// 执行指定次数的迭代
for (int i = 0; i < iterations; i++) {
    func(&result, &TEST_A, &TEST_B);
    // 计算校验和，防止编译器过度优化
    checksum ^= result.limbs[0] ^ result.limbs[1] 
                ^ result.limbs[2] ^ result.limbs[3];
}

// 记录结束时间
double end_time = get_time_ms();
```

**关键点**：
- 使用高精度计时器（Windows: `QueryPerformanceCounter`）
- 通过校验和计算防止编译器优化掉循环
- 确保每次迭代都实际执行算法

### 2.3 结果计算阶段

```c
// 计算总时间（毫秒）
double total_time = end_time - start_time;

// 计算单次操作平均时间（纳秒）
double time_per_op = total_time / iterations * 1000000.0;

// 计算吞吐量（百万次操作/秒）
double throughput = iterations / total_time;
```

## 三、性能指标计算

### 3.1 单次操作平均时间

**公式**：
```
单次操作时间（纳秒）= (总时间（毫秒） / 迭代次数) × 1,000,000
```

**示例**：
- 总时间：65.80 毫秒
- 迭代次数：1,000,000 次
- 单次操作时间 = (65.80 / 1,000,000) × 1,000,000 = **66 纳秒**

### 3.2 吞吐量

**公式**：
```
吞吐量（M ops/sec）= 迭代次数 / 总时间（毫秒）
```

**示例**：
- 迭代次数：1,000,000 次
- 总时间：65.80 毫秒
- 吞吐量 = 1,000,000 / 65.80 = **15.20 M ops/sec**

### 3.3 相对性能

**公式**：
```
相对性能 = 基准算法时间 / 对比算法时间
```

**示例**：
- 传统算法：100 纳秒/操作
- 优化算法：66 纳秒/操作
- 相对性能 = 100 / 66 = **1.52x**（优化算法快 52%）

## 四、为什么使用多次迭代

### 4.1 减少测量误差

单次操作时间极短（纳秒级），直接测量误差很大。通过多次迭代：
- 将总时间放大到毫秒级，提高测量精度
- 减少计时器精度限制的影响
- 降低系统调用开销的占比

### 4.2 平滑系统波动

现代计算机系统存在多种波动因素：
- **CPU频率动态调整**：Turbo Boost、节能模式
- **缓存命中率变化**：首次访问 vs 后续访问
- **操作系统调度**：中断、上下文切换
- **内存访问延迟**：不同内存区域的访问速度

多次迭代可以：
- 平均化这些波动
- 获得更稳定的性能数据
- 反映真实平均性能

### 4.3 提高统计可靠性

大量样本提供：
- 更可靠的统计结果
- 更小的置信区间
- 更好的可重复性

## 五、测试数据

### 5.1 标准测试数据

项目使用固定的测试向量，确保不同算法测试的一致性：

```c
// 测试向量 A
static const bigint256 TEST_A = {
    .limbs = {
        0x123456789ABCDEF0, 
        0xFEDCBA9876543210, 
        0x0011223344556677, 
        0x1899AABBCCDDEEFF
    }
};

// 测试向量 B
static const bigint256 TEST_B = {
    .limbs = {
        0xAAAAAAAAAAAAAAAA, 
        0x5555555555555555, 
        0xCCCCCCCCCCCCCCCC, 
        0x1333333333333333
    }
};
```

### 5.2 数据验证

每次测试都会：
- 计算结果的校验和（Checksum）
- 验证计算的正确性
- 确保算法实现无误

## 六、高精度计时

### 6.1 Windows 平台

```c
double get_time_ms() {
    LARGE_INTEGER frequency, counter;
    QueryPerformanceFrequency(&frequency);  // 获取频率
    QueryPerformanceCounter(&counter);     // 获取当前计数
    return (double)counter.QuadPart * 1000.0 / frequency.QuadPart;
}
```

**特点**：
- 精度：微秒级（通常 < 1 微秒）
- 不受系统时间调整影响
- 适合高精度性能测试

### 6.2 Linux/Unix 平台

```c
double get_time_ms() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000.0 + ts.tv_nsec / 1000000.0;
}
```

**特点**：
- 使用单调时钟，不受系统时间调整影响
- 纳秒级精度
- 跨平台兼容

## 七、测试结果示例

### 7.1 典型输出

```
=== 优化Montgomery算法 ===
Iterations: 1000000
Total time: 65.80 ms
Time per operation: 66.00 ns
Throughput: 15.20 M ops/sec
Checksum: 0x1234567890ABCDEF
Verification: Calculation correctness confirmed
```

### 7.2 性能对比表

| 算法版本              | 迭代次数    | 总时间（ms） | 单次操作（ns） | 吞吐量（M ops/sec） |
|----------------------|------------|-------------|---------------|-------------------|
| 传统模乘算法          | 1,000,000  | 100.00      | 100.00        | 10.00             |
| 优化Montgomery算法   | 1,000,000  | 65.80       | 66.00         | 15.20             |

**性能提升**：优化算法比传统算法快 **52%**（1.52x）

## 八、最佳实践

### 8.1 迭代次数选择

- **快速测试**：10,000 - 100,000 次
- **标准测试**：100,000 - 1,000,000 次
- **详细分析**：1,000,000+ 次
- **稳定性测试**：多次运行，每次 50,000+ 次

### 8.2 测试环境要求

- **关闭其他程序**：减少系统负载
- **固定CPU频率**：禁用Turbo Boost（可选）
- **多次运行**：取平均值
- **记录环境信息**：CPU型号、频率、内存等

### 8.3 结果解读

- **关注平均值**：反映典型性能
- **注意波动范围**：评估稳定性
- **对比相对性能**：而非绝对数值
- **考虑实际应用**：测试数据应接近实际使用场景

## 九、总结

CSIDH-256 项目的性能测评采用**多次迭代平均法**：

1. **预热阶段**：消除冷启动影响
2. **测试阶段**：执行大量迭代（10万或100万次）
3. **计算阶段**：通过总时间除以迭代次数得到平均值

这种方法能够：
- ✅ 获得稳定可靠的性能数据
- ✅ 减少测量误差和系统波动影响
- ✅ 提供可重复的测试结果
- ✅ 准确反映算法的真实性能

**核心原理**：通过大量样本的平均值来估计真实性能，这是统计学中的标准方法，也是性能基准测试的行业标准做法。

---

**文档版本**: 1.0  
**最后更新**: 2025年  
**维护者**: CSIDH-256 项目组


